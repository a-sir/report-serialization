\documentclass[8pt]{beamer}

\usepackage{default}
\usepackage{pscyr} % High quality fonts
\usepackage{color}
\usepackage{minted}

\usepackage{textcomp}

\graphicspath{{images/}}

% \newcommand{\boldunderline}[1]{\textbf{\underline{#1}}}
% \newcommand{\boldit}[1]{\textbf{\textit{#1}}}

\mode<presentation>{\usetheme{Frankfurt}}

\begin{document}

\title{Java binary serialization review}

\author{Sirenko A.}

\begin{frame}
  \titlepage
  \begin{center}
    2014
  \end{center}
\end{frame}

\section{Introduction}
% What is the problem, how do we suggest to solve it?
\renewcommand{\partname}{Requirements}
\subsection{\partname}
\begin{frame}{\partname}
  We use serialization in 2 cases:
  \begin{enumerate}
    \item to store;
    \item to transfer;
  \end{enumerate}

  Main features to consider:
  \begin{enumerate}
    \item serialize/deserialize speed;
    \item serialized size;
    \item stability to change;
    \item laboriousness;
    \item platform-dependence;
  \end{enumerate}

\end{frame}

\renewcommand{\partname}{JDK tools}
\subsection{\partname}
\begin{frame}{\partname}
  \begin{itemize}
    \item Standard serialization: smallest effort / worst performance;
    \item Externalizable serialization: full control over serialization, define your binary format, no features;
  \end{itemize}
  \begin{table}
    \begin{tabular}{l | c | c | c | c | c }
      serialization  & speed & size & stability & laboriousness & platform \\
      &       &      & to change &               & dependence\\
      \hline \hline
      standard       & poor & big   & average & low  & only java  \\
      \hline
      externalizable & fast & small & poor    & high & independent
    \end{tabular}

    \caption{Standard serialization vs Externalizable}
  \end{table}

\end{frame}

\section{Third party libs}
\renewcommand{\partname}{Why use something else?}
\subsection{\partname}
\begin{frame}{\partname}

  Motivation:
  \begin{itemize}
    \item conveniently simple and fast approaches;
    \item better adopted for our data: optional params, variable-length numbers, aliases;
    \item independence from language necessary in some cases.
  \end{itemize}

  Here we consider:
  \begin{itemize}
    \item protobuf - https://code.google.com/p/protobuf/;
    \item avro - http://avro.apache.org/;
    \item kryo - https://github.com/EsotericSoftware/kryo.
  \end{itemize}
\end{frame}

\renewcommand{\partname}{Protobuf}
\subsection{\partname}
\begin{frame}[fragile]{\partname}
  Protobuf info
  \begin{itemize}
    \item needs proto-file with description of your data in primitives;
    \item java, python, c++ officially supported;
    \item performant and compact;
  \end{itemize}


.proto file:
\begin{minted}[fontsize=\tiny]{java}
package tutorial;

option java_package = "com.example.tutorial";
option java_outer_classname = "AddressBookProtos";

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
 }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}

message AddressBook {
  repeated Person person = 1;
}

\end{minted}

\end{frame}

\renewcommand{\partname}{Avro}
\subsection{\partname}
\begin{frame}[fragile]{\partname}
  Avro info
  \begin{itemize}
    \item needs schema-file, can use different schemes to read and write;
    \item java, python, C\\C++, Ruby;
    \item schema stored with data $\Rightarrow$ compact files; no manual
    field-IDs;
    \item code-generational optional for static languages;
  \end{itemize}

  \begin{minted}[fontsize=\tiny]{json}
{
    "type": "record",
    "name": "Employee",
    "fields": [
        {"name": "name", "type": "string"},
        {"name": "age", "type": "int"},
        {"name": "emails", "type": {"type": "array", "items": "string"}},
        {"name": "boss", "type": ["Employee","null"]}
    ]
}
  \end{minted}

\end{frame}

\renewcommand{\partname}{Kryo}
\subsection{\partname}
\begin{frame}[fragile]{\partname}
  Kryo info
\begin{itemize}
  \item Used as standard serialization with custom serializer when you
  need it;
  \item Only java;
  \item For custom serializer there are primitives and features
  (variable-length numbers, positive optimisations);
\end{itemize}

Automatic serialization $\Rightarrow$ not much difference from
standard serialization:

  \begin{minted}[fontsize=\tiny]{java}
    Kryo kryo = new Kryo();

    Output output = new Output(new FileOutputStream("file.bin"));
    SomeClass someObject = ...
    kryo.writeObject(output, someObject);
    output.close();

    Input input = new Input(new FileInputStream("file.bin"));
    SomeClass someObject = kryo.readObject(input, SomeClass.class);
    input.close();
  \end{minted}

\end{frame}

\renewcommand{\partname}{Kryo custom}
\subsection{\partname}
\begin{frame}[fragile]{\partname}

To customize serializer, submit Serializer to Kryo object or
read/write primitives using methods of Input/Output:

 \begin{minted}[fontsize=\tiny]{java}
public class StoredUrl2Serializer extends Serializer<StoredUrl2> {

    @Override
    public void write(Kryo kryo, Output output, StoredUrl2 storedUrl2) {
        output.writeByte(0); // first version of format, placeholder for future versions and optimizations
        output.writeString(this.url.toString());
        output.writeShort(crawlResultCode);
        ...
        output.writeVarInt((int) lastFetchTime, false);
        Kryo.writeObjectOrNull(output, sourceIds, String.class);
        kryo.writeObjectOrNull(output, outLinks2, OutLink[].class);
        ...
        output.writeVarLong(contentLength, false);
    }

    @Override
    public StoredUrl2 read(Kryo kryo, Input input, Class<StoredUrl2> aClass) {
       byte format;
       if ((format = input.readByte()) != 0) {
           throw new RuntimeException("Format not supported: " + format);
       }
       Url url = new Url(input.readString(), false);
       crawlResultCode = input.readShort();
       ...
       long lastFetchTime = input.readVarInt(false);
       @Nullable String sourceIds = kryo.readObjectOrNull(input, String.class);
       @Nullable OutLink[] outLinks = kryo.readObjectOrNull(input, OutLink[].class);
       long contentLength = input.readVarLong(false);
       ...
       return new StoredUrl2(url, ..., contentLength);
    }
 \end{minted}

\end{frame}


\renewcommand{\partname}{Comparison}
\subsection{\partname}
\begin{frame}{\partname}
  Comparison placeholder
\end{frame}

\section{Results}
\renewcommand{\partname}{Kryo vs. Std in queue}
\subsection{\partname}
\begin{frame}{\partname}
  results placeholder
\end{frame}

\end{document}
